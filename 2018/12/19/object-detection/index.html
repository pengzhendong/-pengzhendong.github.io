<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"pengzhendong.cn",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"39IHYBUVGR",apiKey:"4287c8f8a629343c8d2212e108417ceb",indexName:"Notes",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="前言 最近看了几篇关于漏洞检测的文章，将图像处理领域中的目标检测的思想运用到软件的漏洞检测中。话是这么说，但是通篇看下来，其实和目标检测关系并不大，说到底还是对代码行进行分类，判断是否有漏洞。借着这个机会，正好总结一些深度学习课程中的目标检测。"><meta name="keywords" content="Deep Learning"><meta property="og:type" content="article"><meta property="og:title" content="目标检测"><meta property="og:url" content="https://pengzhendong.cn/2018/12/19/object-detection/index.html"><meta property="og:site_name" content="Randy&#39;s Notes"><meta property="og:description" content="前言 最近看了几篇关于漏洞检测的文章，将图像处理领域中的目标检测的思想运用到软件的漏洞检测中。话是这么说，但是通篇看下来，其实和目标检测关系并不大，说到底还是对代码行进行分类，判断是否有漏洞。借着这个机会，正好总结一些深度学习课程中的目标检测。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://pengzhendong.cn/2018/12/19/object-detection/face.png"><meta property="og:image" content="https://pengzhendong.cn/2018/12/19/object-detection/gesture.png"><meta property="og:image" content="https://pengzhendong.cn/2018/12/19/object-detection/windows.png"><meta property="og:image" content="https://pengzhendong.cn/2018/12/19/object-detection/1.png"><meta property="og:image" content="https://pengzhendong.cn/2018/12/19/object-detection/2.png"><meta property="og:image" content="https://pengzhendong.cn/2018/12/19/object-detection/bounding.png"><meta property="og:image" content="https://pengzhendong.cn/2018/12/19/object-detection/5WG68S.jpg"><meta property="og:updated_time" content="2018-12-19T10:02:35.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="目标检测"><meta name="twitter:description" content="前言 最近看了几篇关于漏洞检测的文章，将图像处理领域中的目标检测的思想运用到软件的漏洞检测中。话是这么说，但是通篇看下来，其实和目标检测关系并不大，说到底还是对代码行进行分类，判断是否有漏洞。借着这个机会，正好总结一些深度学习课程中的目标检测。"><meta name="twitter:image" content="https://pengzhendong.cn/2018/12/19/object-detection/face.png"><link rel="canonical" href="https://pengzhendong.cn/2018/12/19/object-detection/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><style type="text/css">body{background-image:url(/images/rockywall.png)}</style><title>目标检测 | Randy's Notes</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-92548519-1"></script><script>if(CONFIG.hostname===location.hostname){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-92548519-1")}</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?06c54470f22c395ef480d6fb358497d5";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Randy's Notes</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-友链"><a href="/friends/" rel="section"><i class="fa fa-users fa-fw"></i> 友链</a></li><li class="menu-item menu-item-书单"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i> 书单</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/pengzhendong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://pengzhendong.cn/2018/12/19/object-detection/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Randy Peng"><meta itemprop="description" content="路漫漫其修远兮 吾将上下而求索"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Randy's Notes"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 目标检测</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-12-19 16:16:29 / 修改时间：18:02:35" itemprop="dateCreated datePublished" datetime="2018-12-19T16:16:29+08:00">2018-12-19</time></span><span id="/2018/12/19/object-detection/" class="post-meta-item leancloud_visitors" data-flag-title="目标检测" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>0</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="前言">前言</h2><p>最近看了几篇关于漏洞检测的文章，将图像处理领域中的目标检测的思想运用到软件的漏洞检测中。话是这么说，但是通篇看下来，其实和目标检测关系并不大，说到底还是对代码行进行分类，判断是否有漏洞。借着这个机会，正好总结一些深度学习课程中的目标检测。</p><a id="more"></a><h2 id="概念">概念</h2><p>在学习目标检测之前首先来了解一下计算机视觉领域中的一些方向和概念，分别是图像分类、定位、语义分割、目标检测和实例分割。</p><ul><li><p>图像分类</p><p>图像分类指用事先确定好的类别来描述图片，例如二分类判断一张图片中是否有猫或者多分类判断图片中手势表示的数字，前面实验中的任务就是图像分类。经典的网络模型就是 LeNet、AlexNet 和 VGG 等等。</p></li><li><p>分类 + 定位</p><p>定位任务不仅要识别出图像中的目标是什么，还要给出其在图像中的位置信息。通常用一个矩形框把识别的目标框出来（有时候也有多个<strong>固定数量</strong>的目标），而我们通常采用两种方式在图像中表示一个矩形框：</p><ol type="1"><li>(x1, y1, x2, y2)： 即给出矩形框左上角和右下角的坐标；</li><li>(x, y, w, h)：即给出矩形框的中心坐标和矩形框的长宽。</li></ol></li><li><p>目标检测</p><p>一幅图像中有多个目标而且目标的<strong>数量不固定</strong>，检测任务要尽可能多的将图像中的目标用矩形框定位出来，相当于对多个目标的定位。目标检测在计算机视觉领域中占据了核心地位，后面的实验也是围绕着目标检测展开。</p></li><li><p>语义分割</p><p>语义分割也叫语义场景标注，是对图像中所有像素进行分类，和目标检测任务不同的是同一个类别的不同实例不需要分割出来。例如图像中有多只猫，那么这些组成猫的像素就都分为同一类。</p></li><li><p>实例分割</p><p>实例分割要求更严格，相对于目标检测来说不再是用矩形框框出目标，相对于语义分割来说不再是对像素进行简单分类。而是要从像素层面上将目标和背景完全分离出来，分割的结果往往是找出目标的轮廓线。</p></li></ul><h2 id="目标定位">目标定位</h2><p>目标定位不仅关注特定目标的类别信息，还要求获得这一目标的位置信息。假设需要定位三类物体，网络最后则输出一个 8 维的向量，第一维表示图像中存在需要定位的目标的概率；第二到第五维表示目标的位置（中心和长宽）；最后三维则表示目标的类别。在训练的过程中，如果第一维为 0 则可以忽略其他维度，即损失函数与其他维度无关。可以对不同的维度使用不同的损失函数，例如对离散的分类结果使用交叉熵损失，对位置信息使用回归损失。</p><h3 id="landmark-定位">Landmark 定位</h3><p>除了对目标进行分类和定位之外，我们还可以对目标的关键特征点（Landmark）进行定位，即已知固定数量的目标，给出每个目标的位置。例如人脸识别，可以对人脸的一部分特征点的坐标进行定位检测，并且标记出来，如下图所示：</p><p><img src="/2018/12/19/object-detection/face.png"></p><p>该模型一共检测人脸 64 处特征点，加上是否是人脸的标志位，输出标签一共有 128+1 个值，通过检测人脸特征点可以进行情绪分类或者对脸部进行瘦脸美颜。除了人脸特征点检测之外，还可以检测人体姿势动作，如下图所示：</p><p><img src="/2018/12/19/object-detection/gesture.png"></p><h2 id="目标检测">目标检测</h2><p>目标检测的一种简单方法是滑动窗口算法，这种算法训练了一个 CNN 分类模型，只不过训练集的图像尺寸较小，尽量仅包含相应目标。模型训练完成后，在测试图片上选择大小适宜的窗口、合适的步长，进行从左到右、从上到下的滑动。每个窗口区域都输入之前训练好的模型进行识别判断。若判断有目标，则此窗口即为目标区域；若判断没有目标，则此窗口为非目标区域。不同大小的窗口如下图所示：</p><p><img src="/2018/12/19/object-detection/windows.png"></p><p>滑动窗口算法原理简单，但是滑动窗口的大小和步长都需要人为直观设定。滑动窗口过小或过大，步长过大均会降低目标检测正确率。而且每次滑动窗区域都要进行一次 CNN 网络计算，如果滑动窗口和步长较小，整个目标检测算法运行时间会很长。</p><h3 id="滑动窗口的卷积实现">滑动窗口的卷积实现</h3><p>窗口在滑动动过程中，其框中的像素会输入到模型中进行卷积运算。由于窗口之间重复的内容比较多，因此会有大量的重复运算。而使用卷积的方式实现滑动窗口算法则可以提高网络的运行速度，节约重复运算成本。</p><p>单个滑动窗口区域进入 CNN 网络模型进行识别判断时，模型包含全连接层。如果滤波器的大小和输入的图像一致，那么卷积层的操作过程就相当于全连接层，因此我们可以将全连接层转变成为卷积层，如下图所示：</p><p><img src="/2018/12/19/object-detection/1.png"></p><p>全连接层参数个数为 <span class="math inline">\((5\times 5\times 16)\times 400\)</span>，使用卷积层替换后一共需要 400 个 <span class="math inline">\(5\times 5\times 16\)</span> 的滤波器。参数个数与全连接层一样，输出也一样。那么卷积实现如何能够节约重复运算成本呢？我们逆向地去思考一下，一个窗口区域图像的目标检测如上图所示，那么一张完整的图像的目标检测呢？假设一张图像在滑动窗口的过程中一共产生 4 个区域，全连接层的形式就只能判断 4 次；而使用卷积实现的方式我们就可以输入整张图像，然后输出 <span class="math inline">\(2\times 2\)</span> 个 4 维向量，即只需要运行模型一次。如下图所示：</p><p><img src="/2018/12/19/object-detection/2.png"></p><p>窗口的大小为 <span class="math inline">\(14\times 14\)</span>，最后输出一个 4 维的向量。一张大一点的图像 <span class="math inline">\(16\times 16\)</span>，步长为 2，滑动窗口可以产生 4 个区域，因此通过模型可以输出一个 <span class="math inline">\(2\times 2\)</span> 的 4 维向量；一张更大的图像 <span class="math inline">\(28\times 28\)</span>，步长为 2，滑动窗口可以产生 64 个区域，模型输出一个 <span class="math inline">\(8\times 8\)</span> 的 4 维向量。因此通过卷积的形式实现滑动窗口算法，可以有效利用卷积的特点减少区域内容的重复计算，提高网络的运行速度，节约重复运算成本。</p><h3 id="边界框预测">边界框预测</h3><p>卷积方式实现的滑动窗口算法，使得在预测时计算的效率大大提高。但是其存在的问题是：不能输出最精准的边界框（Bounding Box）。如图所示，滑动窗口算法产生的滑窗（蓝色）不能完全涵盖目标，即不能输出精确的边界框。</p><p><img src="/2018/12/19/object-detection/bounding.png"></p><h4 id="交并比">交并比</h4><p>交并比（Intersection over Union，简称 IoU）通过计算两个边界框的交集和并集的比来评价对象检测算法，也就是上图中红框和蓝框的交集和并集之比。在目标检测任务中，通常约定交并比大于等于 0.5 就说检测正确。如果两个框完全重合，那么交并比就为 1。</p><h4 id="选择性搜索算法">选择性搜索算法</h4><p>如果暴力枚举各种各样的滑窗参数（大小和步长），那么也可以找到精确的边界框，但是这样时间开销比较大。那么应该如何优化呢？有人提出使用<strong>提议区域的方法</strong>（Region proposal method）创建目标检测的兴趣区域（Regions of Interest，简称 RoI），例如一张图像选 2000 个 RoI，这些区域之间可以互相重叠或者包含，然后再直接对这些区域进行识别判断。</p><p><strong>选择性搜索</strong>（Selective Search，简称 SS）[2] 算法就是一种提议区域的方法，它的主要观点是图像中物体可能存在的区域应该是有某些相似性或者连续性区域的。首先，对输入图像进行分割算法产生许多小的子区域。其次，根据这些子区域之间相似性（相似性标准主要有颜色、纹理、大小等等）进行区域合并，不断的进行区域迭代合并。每次迭代过程中对这些合并的子区域做外切矩形，生成 RoI。</p><p>基于以上思路，人们提出了区域卷积神经网络（Region-based CNN 或 Regions with CNN features，简称 R-CNN）[3]。下面将简单介绍 R-CNN 和它的一系列改进方法：Fast R-CNN [4]、Faster R-CNN [5] 以及掩码 R-CNN（Mask R-CNN）[6]，效果更好的 YOLO(You Only Look Once) [7] 算法将结合着课程实验介绍和实现。</p><h3 id="r-cnn">R-CNN</h3><p>目标检测 <span class="math inline">\(k\)</span> 种类别的 R-CNN 主要分为以下四个步骤：</p><ol type="1"><li>对输入图像使用 SS 来选取大约 2000 个高质量的 RoI 。这些区域通常是在多个尺度下选取的，并具有不同的形状和大小，每个区域将被标注类别和真实边界框；</li><li>选取一个预训练的卷积神经网络，对模型进行微调使其分类数为 <span class="math inline">\(k+1\)</span>。将每个 RoI 裁剪缩放为网络需要的输入尺寸，并通过 CNN 前向传播计算和保存 RoI 的特征；</li><li>将每个 RoI 的特征连同其标注的类别作为一个样本，训练 <span class="math inline">\(k\)</span> 个 SVM 对目标分类。其中每个 SVM 用来判断样本是否属于某一个类别；</li><li>将每个 RoI 的特征连同其标注的边界框作为一个样本，训练线性回归模型来预测真实边界框。</li></ol><p>这个模型和我在自己论文中的思想有一定的相似性，都是单独训练几个模型：用于特征提取的模型和用于分类的模型。模型思路比较简单但是实现比较麻烦，这里值得注意的就是回归模型预测真实边界框，通过 SS 算法得到的边界框可能还不够精确。R-CNN 的主要性能瓶颈在于需要对每个 RoI 独立提取特征。由于这些区域通常有大量重叠，独立的特征提取会导致大量的重复计算。</p><h3 id="fast-r-cnn">Fast R-CNN</h3><p>为了使 R-CNN 更快，Girshick 提出了 Fast R-CNN。一个主要改进在于只对整个图像做卷积神经网络的前向计算；其次三个独立模型合并为了一个联合训练框架并共享计算结果（end-to-end 的形式）。它的主要计算步骤如下：</p><ol type="1"><li>与 R-CNN 相比，Fast R-CNN 用来提取特征的 CNN 的输入是整个图像，而且这个网络通常会参与训练，即更新模型参数；</li><li>SS 在原图像上生成 <span class="math inline">\(n\)</span> 个 RoI，这些形状各异的区域需要映射到 CNN 的输出上；</li><li>将映射后的区域输入全连接层的时候需要固定的形状，与 R-CNN 裁剪缩放操作不同的是，Fast R-CNN 引入 RoI 池化层，将 CNN 输出的特征图和 SS 输出的 RoI 作为输入，提取 RoI 固定形状的特征；</li><li>通过全连接层将输出形状变换为 <span class="math inline">\(n×d\)</span>，其中 <span class="math inline">\(d\)</span> 为隐藏层节点个数；</li><li>类别预测时，将全连接层的输出的形状再变换为 <span class="math inline">\(n×q\)</span> 并使用 softmax 回归（q 为类别个数）。边界框预测时，将全连接层的输出的形状再变换为 <span class="math inline">\(n×4\)</span> 。也就是说，我们为每个 RoI 预测类别和边界框。</li></ol><p>Fast R-CNN 中提出的 RoI 池化层对每个区域的输出形状是可以直接指定的，例如指定每个区域输出的高和宽为 <span class="math inline">\((2, 2)\)</span>。假设某一 RoI 的高和宽为 <span class="math inline">\((5, 7)\)</span>，该窗口将被划分为形状为 <span class="math inline">\((2, 2)\)</span> 的子窗口网格，且每个子窗口的大小大约为 <span class="math inline">\((5/2)×(7/2)\)</span>。任一子窗口的高和宽要取整，其中的最大元素作为该子窗口的输出。因此，RoI 池化层可从形状各异的 RoI 中提取出形状相同的特征。</p><h3 id="faster-r-cnn">Faster R-CNN</h3><p>Fast R-CNN 存在的瓶颈是 SS，通常需要生成很多 RoI。Faster R-CNN 提出将 SS 替换成区域提议网络（Region Proposal Network，简称 RPN），通过训练的方式来获得只与检测目标类别有关的高质量区域，从而减少提议区域的生成数量，并保证目标检测的精度。</p><p>与 Fast R-CNN 相比，只有生成 RoI 的方法从 SS 变成了 RPN 而其他部分均保持不变。RPN 和最后的分类器的损失函数都是由两部分组成：分类的损失和边界框的回归损失。只不过 RPN 只需要进行二分类，即分析窗口中内容为目标还是背景，而不需要判断目标的类别。</p><p>文章使用了两种 CNN 来提取特征：Zeiler and Fergus（简称 ZF）网络和 Simonyan and Zisserman 网络（即 VGG-16）。前者输出的特征图为 256 通道，后者输出的特征图为 512 通道，以下内容均基于 VGG-16 网络作为卷积层。首先将输入 VGG-16 网络的图像缩放成 <span class="math inline">\(800\times 600\)</span>，网络下采样后 16 倍后输出的特征图大小为 <span class="math inline">\(50\times 37\times 512\)</span>，然后将其输入 RPN 网络提取感兴趣区域。</p><h4 id="rpn">RPN</h4><p>特征图中一共有 <span class="math inline">\(50\times 37\)</span> 个 512 维的向量，每一个 512 维特征向量都对应原图在卷积过程中滑窗产生的区域，如<a href="#滑动窗口的卷积实现">滑动窗口的卷积实现</a>所示。 相当于是将大小为 <span class="math inline">\(800\times 600\)</span> 的图像分割成 <span class="math inline">\(50\times 37\)</span> 个大小一样的区域，由于 VGG-16 卷积层的步长不等于滤波器的大小，因此这些区域之间有重叠但是覆盖了整张图像，最后 VGG-16 为每个区域提取了一个 512 维的特征向量，RPN 网络就是要找到每个区域中目标的边界框。</p><h5 id="锚框">锚框</h5><blockquote><p>以每个像素为中心生成多个大小和宽高比（aspect ratio）不同的边界框，这些边界框被称为锚框（anchor box）。</p></blockquote><p>如果多个待检测目标的中心在同一个区域内，我们首先根据数据集手工对原图上每一个区域生成各种各样形状和大小的锚框，保证锚框可以框住所有种类的目标。作者为每个区域手动指定了 <span class="math inline">\(k=9\)</span> 种不同大小和比例的锚框。</p><p>一共有 <span class="math inline">\(50\times 37\times 9=16650\)</span> 个锚框，基本上覆盖了所有可能出现的目标。这些人工指定锚框的内容大部分只有背景而且也很难精确地框中目标，给定一张人工标注好的图像，任何一个生成的锚框如果和人工标注的目标的边界框之间的 IoU &gt; 0.7，就可以认为该锚框的真实标签为前景并且得到其真实的边界框；IoU &lt; 0.3 则认为该锚框的真实标签为背景；其余的不参与训练。得到了锚框的真实标签，我们就可以对其进行训练，因此一个区域需要输出 <span class="math inline">\(2k\)</span> 个分数来进行二分类和 <span class="math inline">\(4k\)</span> 个值来进行边界框回归。</p><h5 id="提议区域">提议区域</h5><p>模型训练完毕后，我们就可以使用模型的前向传播部分对新的数据进行处理，步骤如下所示：</p><ol type="1"><li>输入新的特征图，生成锚框，对所有的锚框进行边界框回归和分类；</li><li>对所有的锚框按照其为前景的分数进行排序，取前 6000 个；</li><li>对回归后的锚框进行处理，例如去除过长度或者宽度过小的锚框；</li><li>进行非极大值抑制，然后再次对所有的锚框按照其为前景的分数进行排序，取前 300 个作为提议区域输出。</li></ol><h5 id="非极大值抑制">非极大值抑制</h5><p>在对锚框进行边界框回归后，对于同一个目标，可能有多个边界框与其对应，于是我们就要用到非极大值抑制，来抑制那些冗余的框，其过程如下所示：</p><ol type="1"><li>将所有框的得分排序，选中最高分及其对应的框，例如上图中 0.9；</li><li>遍历其余的框，如果和当前最高分框的 IoU 大于一定阈值（通常取 0.5），我们就将框删除，例如上图中 0.6;</li><li>从未处理的框中继续选一个得分最高的，例如上图中 0.8，重复上述过程。</li></ol><p>RPN 作为 Faster R-CNN 的一部分，是和整个模型一起训练得到的。即 Faster R-CNN 的目标函数既包括目标检测中的类别和边界框预测，也包括 RPN 中锚框的二元类别和边界框预测。最终 RPN 能够学习到如何生成高质量的RoI，从而在减少 RoI 数量的情况下也能保证目标检测的精度。</p><h3 id="mask-r-cnn">Mask R-CNN</h3><p>如果训练数据还标注了每个目标在图像上的像素级位置，那么 Mask R-CNN 能有效利用这些详尽的标注信息进一步提升目标检测的精度，例如进行实例分割，在每一个像素上都表示出来目标所属的具体类别。</p><p>Mask R-CNN 在 Faster R-CNN 的基础上做了修改，引入一个全卷积网络。即增加了一个分支，用于输出一个二值掩膜，如下图所示，最后输出一个 80 通道的 <span class="math inline">\(14\times 14\)</span> 的二值矩阵，分别表示是否 80 个分类中的某一类。</p><h4 id="roialign">RoIAlign</h4><p>RoI 池化层有两个步骤会产生区域不匹配的问题，假设 CNN 下采样倍数为 32，原图中 RoI 的大小为 <span class="math inline">\(665\times 665\)</span>，经过网络后对应的区域大小为 <span class="math inline">\(\frac{665}{32}\times \frac{665}{32}\)</span>，向下取整会产生区域不匹配问题，即映射回原图大小不一致；将 RoI 的特征图输入全连接网络之前需要固定形状，在划分 bins （对应图中的 sections）的时候如果无法整除也需要向下取整，再次产生区域不匹配的问题，对于目标检测比较小的目标、语义分割和实例分割任务影响就会比较大。因此作者提出了 RoIAlign，全程可以使用浮点数操作，不存在取整过程。假设原图大小为 <span class="math inline">\(800\times 800\)</span>，RoIAlign 的步骤如下所示：</p><p><img src="/2018/12/19/object-detection/5WG68S.jpg"></p><ol type="1"><li>计算 RoI 在特征图中的边长，不取整，即边长为 <span class="math inline">\(\frac{665}{32}=20.78\)</span>；</li><li>假设输入全连接网络的特征为 <span class="math inline">\(7\times 7\)</span>，每个 bin 的大小不取整，即边长为 <span class="math inline">\(\frac{20.78}{7}=2.97\)</span>；</li><li>RoI 池化层得到的 bin 的边长是整数，然后输出整数。而 RoIAlign 需要对区域采样，例如采样点数为 4，用须线把 bin 平均分成 4 份，每一份取中心点位置的像素，即 <font color="red">x</font> 处的像素值；</li><li>每个 <font color="red">x</font> 处的像素值为其最邻近的四个值通过双线性插值得到。</li></ol><h5 id="双线性差值">双线性差值</h5><p>数值分析这门课学得最熟的也就是插值法了，首先是线性插值，给定 <span class="math inline">\((x_0, y_0)\)</span> 和 <span class="math inline">\((x_1, y_1)\)</span>，估计 <span class="math inline">\([x_0, x_1]\)</span> 区间内某一位置 <span class="math inline">\(x\)</span> 在直线上的 <span class="math inline">\(y\)</span> 值： <span class="math display">\[ y = \frac{x_1 - x}{x_1 - x_0}y_0 +\frac{x - x_0}{x_1 - x_0}y_1 \]</span> 双线性插值就是相继在两个坐标轴上做线性差值，先分别对 <font color="red">x</font> 上方两个像素值和下方的两个像素值在 <span class="math inline">\(x\)</span> 轴上进行线性插值得到 <span class="math inline">\(R_1\)</span> 和 <span class="math inline">\(R_2\)</span>，再由 <span class="math inline">\(R_1\)</span> 和 <span class="math inline">\(R_2\)</span> 在 $y $ 轴上进行线性插值得到最终结果。</p><h2 id="总结">总结</h2><p>粗略学习了以下 R-CNN 以及一些列的改进，首先是 R-CNN 使用选择性搜索算法，先找出一些边界框再分别输入 CNN，避免了滑动窗口算法边界框不准确的问题；其次是 Fast R-CNN 将整张图片输入 CNN 提取特征后再把边界框映射过去，避免了 R-CNN 再分析边界框的过程中重复运算的问题；然后是 Faster R-CNN 直接在网络里面学习找出高质量的边界框，避免了 Fast R-CNN 中选择性搜索算法盲目找边界框；最后是 Mask R-CNN 改进了 RoI 池化层，避免了 Faster R-CNN 中区域不匹配的问题，同时添加了一个分支用于掩码预测每一个像素的分类，最后可以做到语义分割和实例分割。</p><p>以上图片来自于《动手学深度学习》，发现这是大神李沐写的，该花点时间好好提升一下自己的代码水平了。</p><h2 id="参考文献">参考文献</h2><ol type="1"><li>吴恩达. DeepLearning.</li><li>Van de Sande K E A, Uijlings J R R, Gevers T, et al. Segmentation as selective search for object recognition[C]//Computer Vision (ICCV), 2011 IEEE International Conference on. IEEE, 2011: 1879-1886.</li><li>R. Girshick, J. Donahue, T. Darrell, and J. Malik. Rich feature hierarchies for accurate object detection and semantic segmentation. In CVPR, 2014.</li><li>Girshick, R. (2015). Fast r-cnn. arXiv preprint arXiv:1504.08083.</li><li>Ren, S., He, K., Girshick, R., &amp; Sun, J. (2015). Faster r-cnn: Towards real-time object detection with region proposal networks. In Advances in neural information processing systems (pp. 91-99).</li><li>He, K., Gkioxari, G., Doll á r, P., &amp; Girshick, R. (2017, October). Mask R-CNN. In Computer Vision (ICCV), 2017 IEEE International Conference on (pp. 2980-2988). IEEE.</li><li>Redmon J, Divvala S, Girshick R, et al. You only look once: Unified, real-time object detection[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2016: 779-788.</li><li>J. Long, E. Shelhamer, and T. Darrell. Fully convolutional networks for semantic segmentation. In CVPR, 2015. 1, 3, 6</li><li>《动手学深度学习》. http://zh.diveintodeeplearning.org/index.html</li></ol></div><div class="reward-container"><div>疏影横斜水清浅，暗香浮动月黄昏</div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/images/wechatpay.png" alt="Randy Peng 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/images/alipay.png" alt="Randy Peng 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> Randy Peng</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://pengzhendong.cn/2018/12/19/object-detection/" title="目标检测">https://pengzhendong.cn/2018/12/19/object-detection/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><center><br><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5aa9d6309315fb5e" async="async"></script></div></center><footer class="post-footer"><div class="post-tags"> <a href="/tags/Deep-Learning/" rel="tag"># Deep Learning</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2018/12/12/resnet/" rel="prev" title="残差网络 ResNet"><i class="fa fa-chevron-left"></i> 残差网络 ResNet</a></div><div class="post-nav-item"> <a href="/2019/01/08/autonomous-driving/" rel="next" title="自动驾驶">自动驾驶<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目标定位"><span class="nav-number">3.</span> <span class="nav-text">目标定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#landmark-定位"><span class="nav-number">3.1.</span> <span class="nav-text">Landmark 定位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目标检测"><span class="nav-number">4.</span> <span class="nav-text">目标检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#滑动窗口的卷积实现"><span class="nav-number">4.1.</span> <span class="nav-text">滑动窗口的卷积实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#边界框预测"><span class="nav-number">4.2.</span> <span class="nav-text">边界框预测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#交并比"><span class="nav-number">4.2.1.</span> <span class="nav-text">交并比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择性搜索算法"><span class="nav-number">4.2.2.</span> <span class="nav-text">选择性搜索算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#r-cnn"><span class="nav-number">4.3.</span> <span class="nav-text">R-CNN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fast-r-cnn"><span class="nav-number">4.4.</span> <span class="nav-text">Fast R-CNN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#faster-r-cnn"><span class="nav-number">4.5.</span> <span class="nav-text">Faster R-CNN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rpn"><span class="nav-number">4.5.1.</span> <span class="nav-text">RPN</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#锚框"><span class="nav-number">4.5.1.1.</span> <span class="nav-text">锚框</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#提议区域"><span class="nav-number">4.5.1.2.</span> <span class="nav-text">提议区域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#非极大值抑制"><span class="nav-number">4.5.1.3.</span> <span class="nav-text">非极大值抑制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mask-r-cnn"><span class="nav-number">4.6.</span> <span class="nav-text">Mask R-CNN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#roialign"><span class="nav-number">4.6.1.</span> <span class="nav-text">RoIAlign</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#双线性差值"><span class="nav-number">4.6.1.1.</span> <span class="nav-text">双线性差值</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">6.</span> <span class="nav-text">参考文献</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Randy Peng" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Randy Peng</p><div class="site-description" itemprop="description">路漫漫其修远兮 吾将上下而求索</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">34</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/pengzhendong" title="GitHub → https://github.com/pengzhendong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://twitter.com/pengzhendong" title="Twitter → https://twitter.com/pengzhendong" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i> Twitter</a></span><span class="links-of-author-item"><a href="mailto:275331498@qq.com" title="E-Mail → mailto:275331498@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.facebook.com/pengzhendong" title="FaceBook → https://www.facebook.com/pengzhendong" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i> FaceBook</a></span><span class="links-of-author-item"><a href="https://t.me/pengzhendong" title="Telegram → https://t.me/pengzhendong" rel="noopener" target="_blank"><i class="fab fa-telegram fa-fw"></i> Telegram</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/pengzhendong" title="知乎 → https://www.zhihu.com/people/pengzhendong" rel="noopener" target="_blank"><i class="fab fa-leanpub fa-fw"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://weibo.com/qq275331498" title="微博 → https://weibo.com/qq275331498" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i> 微博</a></span><span class="links-of-author-item"><a href="/about" target="_self" title="关于 → /about" target="_self"><i class="fa fa-user fa-fw"></i> 关于</a></span></div><hr style="margin-top:20px;margin-bottom:20px"> <img src="/images/wechat.png"></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2015 – <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Randy Peng</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">258k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">3:55</span></div><script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"YHMwvrTgcfDjOXmiGY3jQ2r5-gzGzoHsz","app_key":"JRfKfM8mRPgxMB9GOSAnix9W","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script><script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script></body></html>